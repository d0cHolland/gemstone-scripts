#masterfletcher
@settings = CharSettings.to_hash
@settings['fletch_sack'] ||= UserVars.lootsack
@settings['fletch_quiver'] ||= UserVars.lootsack
@settings['fletch_knife'] ||= ""
@settings['fletch_bow'] ||= ""
@settings['fletch_enable_buying'] ||= false
@settings['fletch_paint'] ||= 0
@settings['fletch_paintstick1'] ||= ""
@settings['fletch_paintstick2'] ||= ""
@settings['fletch_tip'] ||= nil
@settings['fletch_wood'] ||= "limb of wood"
@settings['fletch_axe'] ||= ""
@settings['fletch_fletchings'] ||= "bundle of fletchings" 
@settings['fletch_limit'] ||= ""
@settings['fletch_drop'] ||= false
@settings['timeout_duration'] ||= 3
@container_contents = nil
@needed_items = nil
@start_time = Time.now
@arrows_made = 0
@arrows_failed = 0
@spent_silver = 0
@finished = false

fletching_report = proc { |client_string|
    if client_string =~ /^(?:<c>)?#{$clean_lich_char}(?:fletching)$/i
        respond ""
		respond "Script has been running for #{Time.at(Time.now - @start_time).strftime("%H hours, %M minutes %S seconds")}, made #{arrows_made} arrows, ruined #{arrows_failed} arrows and spent #{spent_silver} silver"
		respond ""
	elsif client_string =~ /^(?:<c>)?#{$clean_lich_char}fletching (?:stop|done|end|finish|finished)$/i
		@finished = true
		respond ""
		respond "Once current arrow is complete script will end"
		respond ""
    else
        client_string
    end
}
UpstreamHook.add('fletching_hook', fletching_report)
before_dying{;UpstreamHook.remove('fletching_hook');}

@paints = {
			0	=> 'none',		
			1	=> 'bright golden paint',
			2	=> 'fiery orange paint',
			3	=> 'bright yellow paint',
			4 	=> 'dark russet paint',
			5	=> 'dark brown paint',
			6	=> 'silvery grey paint',
			7	=> 'twilight grey paint',
			8	=> 'storm grey paint',
			9	=> 'charcoal grey paint',
			10	=> 'icy blue paint',
			11	=> 'midnight blue paint',
			12	=> 'dusky blue paint',
			13	=> 'silvery white paint',
			14	=> 'bone white paint',
			15	=> 'pure white paint',
			16	=> 'glossy black paint',
			17	=> 'dull black paint',
			18	=> 'inky black paint',
			19	=> 'forest green paint',
			20	=> 'hunter green paint',
			21	=> 'dark green paint',
			22	=> 'blood red paint',
			23	=> 'glossy red paint',
			24	=> 'dull red paint',
		}

@setup = proc {
	gtk_global = Hash.new
	window = window_action = nil
	Gtk.queue {
		ttips = Gtk::Tooltips.new.enable
		ttips_text = {
			'fletch_sack' => 'This is the container all your supplies, axe and dagger will be in',
			'fletch_quiver' => 'This is the container you want your finshed arrows to be stored in, it can be the same as the container above if you wish',
			'fletch_axe' => 'This is the axe you will use for creating the shafts, needs to be what ever you would type following the get comand to remove it from your container.' ,
			'fletch_knife' => 'This is the knife or dagger you will be using to cut the shafts, needs to be what ever you would type following the get comand to remove it from your container.' ,
			'fletch_bow' => 'This is the bow you will be using to measure the shaft, MUST BE WORN!',
			'fletch_enable_painting' => 'Check this if you would like to paint your arrows',
			'fletch_enable_buying' => 'Check this if you would like the script to go buy wood, glue and fletchings from the shop',
			'fletch_drop' => 'Check this if you would like to drop completed arrows, instead of stowing them.',
			'fletch_wood' => 'The name of the wood you would like to buy, leaving off a/an/some at the start. Eg. "limb of faewood" or "branch of kakore"',
			'fletch_paint' => 'The name of the paint you would like to buy, leaving off a/an/some at the start',
			'fletch_paintstick1' => 'Leave blank if you do not want to use a paintstick to crest your arrows. If you want to crest you arrows please enter the colour of the paintstick.',
			'fletch_paintstick2' => 'Leave blank if you do not want to use a paintstick to crest your arrows a second time. If you want to crest you arrows a second time please enter the colour of the paintstick.',
			'fletch_fletchings' => 'The name of the fletchings you would like to buy, leaving off a/an/some at the start.',
			'fletch_tip' => 'The name of the arrowhead or cap you wish to add.',
			'fletch_limit' => 'This is the number of arrows you would like the script to make, leave blank for no limit. It will just keep making more till you tell it to stop, run out of space or run out of money.',
			'timeout_duration' => 'This number is how many seconds the script will allow for certain actions before timing out. Increasing the number may help in times that the game is lagging.'
		}
		
		gtk_global['fletch_sack'] = Gtk::Entry.new.set_text(@settings['fletch_sack'])
		gtk_global['fletch_quiver'] = Gtk::Entry.new.set_text(@settings['fletch_quiver'])
		gtk_global['fletch_axe'] = Gtk::Entry.new.set_text(@settings['fletch_axe'])
		gtk_global['fletch_knife'] = Gtk::Entry.new.set_text(@settings['fletch_knife'])
		gtk_global['fletch_bow'] = Gtk::Entry.new.set_text(@settings['fletch_bow'])
		gtk_global['fletch_enable_buying'] = Gtk::CheckButton.new.set_active(@settings['fletch_enable_buying'])#Gtk::Entry.new.set_text(@settings['fletch_enable_buying'])
		gtk_global['fletch_drop'] = Gtk::CheckButton.new.set_active(@settings['fletch_drop'])
		gtk_global['fletch_wood'] = Gtk::Entry.new.set_text(@settings['fletch_wood'])
		gtk_global['fletch_paint'] = Gtk::ComboBox.new(is_text_only = true)
		gtk_global['fletch_paintstick1'] = Gtk::Entry.new.set_text(@settings['fletch_paintstick1'])
		gtk_global['fletch_paintstick2'] = Gtk::Entry.new.set_text(@settings['fletch_paintstick2'])
		gtk_global['fletch_tip'] = Gtk::Entry.new.set_text(@settings['fletch_tip'])
		gtk_global['fletch_fletchings'] = Gtk::Entry.new.set_text(@settings['fletch_fletchings'])
		gtk_global['fletch_limit'] = Gtk::Entry.new.set_text(@settings['fletch_limit'].to_s)
		gtk_global['waggle'] = Gtk::CheckButton.new.set_active(@settings['waggle'])
		gtk_global['timeout_duration'] = Gtk::Entry.new.set_text(@settings['timeout_duration'].to_s)
		
		#use @paints array to form combox
		x = 0
		while x < @paints.length
			gtk_global['fletch_paint'].append_text(@paints[x])
			x += 1
		end
		gtk_global['fletch_paint'].set_active(@settings['fletch_paint']) #have to set active after apending
		
		
		
		
		ttips_text.each_pair { |widget,tip|
			if widget = gtk_global[widget]# || gtk_locals[widget]
				ttips.set_tip(widget,tip,'')
			end
		}
		
		window = Gtk::Window.new
		window.title = "Fletching"
		window.border_width = 3
		window.resizable = true
		#window.resize(10, 10)
		
		settings_page = Gtk::VBox.new(false,1).set_border_width(3)
		vb_pg1_1 = Gtk::VBox.new(false,1).set_border_width(3)
		fr_pg1_1 = Gtk::Frame.new.set_border_width(5).set_label_widget(Gtk::Label.new.set_markup('<big><b>@settings</b></big>'))
		fr_pg1_1.add(vb_pg1_1)
		settings_page.pack_start(fr_pg1_1,false)

		#random note to self width will be ignored if text is longer
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Supplies Container: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_sack'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Finished Container: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_quiver'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Axe: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_axe'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Knife: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_knife'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Bow: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_bow'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Buy Items: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_enable_buying'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false, 1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Drop Arrows: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_drop'], false)
		vb_pg1_1.pack_start(hb, false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Wood: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_wood'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paint: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_paint'].set_width_request(158),false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paintstick 1: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_paintstick1'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paintstick 2: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_paintstick2'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Fletchings: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_fletchings'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Tip Name: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_tip'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Make limit: ')).set_width_request(120))
		hb.pack_start(gtk_global['fletch_limit'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Make limit: ')).set_width_request(120))
		hb.pack_start(gtk_global['timeout_duration'],false)
		vb_pg1_1.pack_start(hb,false)
		
		hb = Gtk::HBox.new(false,1)
		hb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Use waggle: ')).set_width_request(120))
		hb.pack_start(gtk_global['waggle'],false)
		vb_pg1_1.pack_start(hb,false)
		
		
		#cb = Gtk::ComboBox.new
		#cb.append_text 'Ubuntu'
		#cb.append_text 'Mandriva'
		#cb.append_text 'Redhat'
		#cb.append_text 'Gento'
		#cb.append_text 'Mint' 
		#cb.pack_start(Gtk::Alignment.new(1,0,0,1).add(Gtk::Label.new('Paint: ')).set_width_request(120))
		#cb.pack_start(gtk_global['fletch_paint'],false)
		#cb.pack_start(cb.append_text 'Ubuntu')
		#vb_pg1_1.pack_start(cb,false)
		
		lbl = Gtk::Label.new.set_markup("Mouse over each box for more help")
		lbl.set_wrap(true).set_padding(0,10)
		vb_pg1_1.pack_start(lbl,false)
		
		hb_saveclose = Gtk::HBox.new(false,1)
		save = Gtk::Button.new('_Save & Close')
		close = Gtk::Button.new('E_xit')
		save.signal_connect('clicked') { window_action = :save }
		close.signal_connect('clicked') { window_action = :done }
		hb_saveclose.pack_start(save,false)
		hb_saveclose.pack_start(close,false)
		vb_pg1_1.pack_start(hb_saveclose,false)
		
		
		
		
		
		# Primary VerticalBox to split up Notebook and Save/Close buttons
		#vb_main = Gtk::VBox.new(false,1)
		#vb_main.border_width = 3
		
		#vb_main.pack_start(nb,false)
		#vb_main.pack_start(hb_saveclose,false)
		
		window.signal_connect('delete_event') { respond window.allocation.width; respond window.allocation.height; window_action = :exit }
		
		#window.add(vb_main)	
		
		
		window.add(settings_page)
		
		
		
		window.show_all
		window.keep_above = true # On windows keep_above is required AFTER show_all
		
	}
	before_dying { Gtk.queue { window.destroy } }
	wait_while { window_action.nil? }
	undo_before_dying
	Gtk.queue { window.destroy }
	clean_entry = proc { |entry|
		entry.text = entry.text.strip
		if entry.text.empty?
			entry.text = nil
		end
		
		entry.text
	}
		
	if window_action == :save		
		gtk_global.each_pair { |option,widget|
			
			if widget.class == Gtk::CheckButton
				@settings[option] = widget.active?
			elsif widget.class == Gtk::Entry
				@settings[option] = clean_entry.call(widget)
			elsif widget.class == Gtk::ComboBox
				@settings[option] = widget.active
			else
				echo "error: unknown local widget #{option} [#{widget.class}]"
			end
		}
		
		#attempt some error checking
		warning = ""
		if @settings['fletch_sack'] == ""
			warning += "The container for you supplies has not yet been set, the script will not run untill this is added.\r\n"
		end
		if @settings['fletch_quiver'] == ""
			warning += "The container for you finished arrows has not yet been set, the script will not run untill this is added.\r\n"
		end
		if @settings['fletch_knife'] == ""
			warning += "Have not set a knife/dagger to cut the shafts with, the script will not run untill this is added.\r\n"
		end
		if @settings['fletch_bow'] == ""
			warning += "Have not set a bow to measure the shafts with, the script will not run untill this is added.\r\n"
		end
		if @settings['fletch_axe'] == ""
			warning += "Have not set an axe to make shafts with, the script will not run untill this is added.\r\n"
		end
		if @settings['fletch_wood'] == ""
			warning += "Have not set a what wood you want to use, the script will not run untill this is added.\r\n"
		end
		if @settings['fletch_wood'] != "" and @settings['fletch_wood'] !~ /wood/
			warning += "You have set what wood you want to use but appears you may have done so incorectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example.\r\n"
		end
		if @settings['fletch_wood'] =~ /\s*a |\s*an |\s*some /
			@settings['fletch_wood'].gsub!(/\s*a |\s*an |\s*some /, '')
		end
		if @settings['fletch_paintstick1'] != "" and @settings['fletch_paintstick1'] !~ /paintstick/
			@settings['fletch_paintstick1'] = "#{@settings['fletch_paintstick1'].strip} paintstick"
		end
		if @settings['fletch_paintstick2'] != "" and @settings['fletch_paintstick2'] !~ /paintstick/
			@settings['fletch_paintstick2'] = "#{@settings['fletch_paintstick2'].strip} paintstick"
		end
		if @settings['fletch_fletchings'] != "" and @settings['fletch_fletchings'] !~ /fletching/
			warning += "You have set what fletchings you want to use but appears you may have done so incorectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
		end
		if @settings['fletch_fletchings'] =~ /\s*a |\s*an |\s*some /
			@settings['fletch_fletchings'].gsub!(/\s*a |\s*an |\s*some /, '')
		end
		if warning.length > 0
			if !$fake_stormfront
				puts "<output class=\"mono\"/>#{monsterbold_start}#{warning}#{monsterbold_end}\r\n<output class=\"\"/>"
			else
				puts "#{monsterbold_start}#{warning}#{monsterbold_end}"
			end
		end
		echo '@settings saved'
	else
		echo 'closed without saving'
	end
}

def monitor_interaction()
        #if @MONITOR_INTERACTION
echo "here"
start_exec_script( <<-eos
	def show_window(line);
	window_title = Char.name + ':' + line;
	Gtk.queue {
		$myWindow = Gtk::Window.new;
		$myWindow.title = "Autobot Alert!";
		$myWindow.set_size_request(450, 25);
		label = Gtk::Label.new window_title;
		$myWindow.add(label);
		$myWindow.show_all;
	};
	end;
	while(line = get);
		break unless running?('fletching');
		if(line =~ /SEND|POLICY|[Rr](\s)*[Ee](\s)*[Pp](\s)*[Oo](\s)*[Rr](\s)*[Tt]|peaking to you|unresponsive|taps you|nods to you|lease respond|not in control|character|violation|lease speak|peak out loud|Y U SHOU D|whispers,|speaking to you|smiles at you|waves to you|grins at you|hugs you|takes hold your hand|grabs your hand|clasps your hand|trying to drag you/);
			unless(line =~ /LNet/);
				show_window(line);
				echo "AUTOBOT ALERT: " + line;
			end;
		end;
	end;
	eos
)
end

def checkSettings()

	if @settings['fletch_sack'] == "" or @settings['fletch_sack'].nil?
		warning += "The container for you supplies has not yet been set, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_quiver'] == "" or @settings['fletch_quiver'].nil?
		warning += "The container for you finished arrows has not yet been set, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_knife'] == ""
		warning += "Have not set a knife/dagger to cut the shafts with, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_bow'] == ""
		warning += "Have not set a bow to measure the shafts with, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_axe'] == ""
		warning += "Have not set an axe to make shafts with, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_wood'] == ""
		warning += "Have not set a what wood you want to use, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_wood'] != "" and @settings['fletch_wood'] !~ /wood/
		warning += "You have set what wood you want to use but appears you may have done so incorectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example. Leave off any a/an/some from the start\r\n"
	end
	if @settings['fletch_fletchings'] != "" and @settings['fletch_fletchings'] !~ /fletching/
		warning += "You have set what fletchings you want to use but appears you may have done so incorectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
	end
end

def checksilver
	silvers = nil
	action = proc { |server_string|
		if server_string =~ /^\s*Name\:|^\s*Gender\:|^\s*Normal \(Bonus\)|^\s*Strength \(STR\)\:|^\s*Constitution \(CON\)\:|^\s*Dexterity \(DEX\)\:|^\s*Agility \(AGI\)\:|^\s*Discipline \(DIS\)\:|^\s*Aura \(AUR\)\:|^\s*Logic \(LOG\)\:|^\s*Intuition \(INT\)\:|^\s*Wisdom \(WIS\)\:|^\s*Influence \(INF\)\:/
			nil
		elsif server_string =~ /^\s*Mana\:\s+\-?[0-9]+\s+Silver\:\s+([0-9]+)/
			silvers = $1.to_i
			DownstreamHook.remove("slib_check_silvers")
			nil
		else
			server_string
		end
	}
	DownstreamHook.add("slib_check_silvers", action)
	$_SERVER_.puts "#{$cmd_prefix}info\n"
	wait_until { silvers }
	silvers
end

def get_container_contents(container_name)
	if container_name.nil?
		echo 'Blank name passed to get_container_contents'
		sleep 1
		exit
	else
		container_contents = GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name.strip)}/i } || GameObj.inv.find { |obj| obj.name =~ /#{Regexp.escape(container_name).sub(' ', ' .*')}/i }
		if container_contents.nil?
			echo "warning: failed to find your fletchsack (#{container_name})"
			sleep 1
		else
			if container_contents.contents.nil?
				open_result = dothistimeout "open ##{container_contents.id}", @settings['timeout_duration'].to_i, /You open|already open/
				close_container_contents = true if open_result =~ /You open/
				if container_contents.contents.nil?
					dothistimeout "look in ##{container_contents.id}", @settings['timeout_duration'].to_i, /In the .* you see/
					if container_contents.contents.nil?
						echo "warning: failed to find the contents of your fletchsack (#{container_name})"
						sleep 1
					end
				end
			end
		end
	end
	return container_contents.contents
end

def check_needed_items(fletch_sack_contents)
	items = Array.new
	needed_items = Array.new
	need_wood = true
	need_paint = true
	need_glue = true
	need_fletchings = true
	need_paintstick1 = true
	need_paintstick2 = true
	#check container and if we have it mark as not needed
	fletch_sack_contents.each{|item|
		#fixme: see if can get more specfic then shaft
		if item.name =~ /shaft/ or item.name =~ /#{@settings['fletch_wood']}/
			need_wood = false
		elsif item.name =~ /#{@paints[@settings['fletch_paint']]}/
			need_paint = false
		elsif item.name =~ /#{@settings['fletch_fletchings']}/
			need_fletchings = false
		elsif item.name =~ /bottle of fletching glue/
			need_glue = false
		elsif item.name =~ /#{@settings['fletch_paintstick1']}/ and @settings['fletch_paintstick1'].length > 0
			need_paintstick1 = false
		elsif item.name =~ /#{@settings['fletch_paintstick2']}/ and @settings['fletch_paintstick2'].length > 0
			need_paintstick2 = false
		end
	}
	
	needed_items = Array.new
	
	if need_wood
		needed_items << @settings['fletch_wood']
	end
	if need_glue
		needed_items << "bottle of fletching glue"
	end
	if need_fletchings
		needed_items << @settings['fletch_fletchings']
	end
	if need_paint and @settings['fletch_paint'] != 0
		needed_items << "vial of paint"
	end
	if need_paintstick1 and @settings['fletch_paintstick1'].length > 0
		needed_items << @settings['fletch_paintstick1']
	end
	if need_paintstick2 and @settings['fletch_paintstick2'].length > 0
		needed_items << @settings['fletch_paintstick2']
	end
	
	return needed_items
end

def find_order_num(supply)

	status_tags
	clear
	fput 'unhide' if hidden? or invisible?
	fput 'order'
	menu = Hash.new
	while (line = get) and (line !~ /ORDER|BUY/)
		for item in line.scan(/<d.*?cmd=["']order ([0-9]+).*?>(.*?)<\/d>/)
			menu[item[1].sub(/^a /, '')] = item[0]
		end
	end
	clear
	status_tags
	
	#menu = read_menu.call
	#echo menu.inspect
	
	item_name = menu.keys.find { |name| name =~ /#{supply}/i }
	unless order_number = menu[item_name]
		echo ""
		echo "Error: failed to find the item! Remember to leave off the a/an/some at the start. eg. 'limb of faewood"
		echo ""
	end
	return order_number
	
end

def buy_items()
	if invisible?
		invis = true
	else 
		invis = false
	end
	start_room = Room.current.id
	silver = checksilver
	if silver < 5000
		silver = 5000 - silver
		start_script "go2",['bank']
		wait_while {running?("go2")}
		fput "unhide" if hidden? or invisible?
		fput "withdraw #{silver}"
		if checksilver < 5000
			echo "Failed to get money from the bank"
			exit
		end
	end
	start_script "go2",['fletcher']
	wait_while {running?("go2")}
	move "south" if Room.current.location == "Ta'Vaalor"
					
	if checkleft != nil
		empty_left_hand
	end
	if checkright != nil
		empty_right_hand
	end
	@needed_items.each {|item|
		
		if item =~ /vial of paint/
			order_number = find_order_num(item)
			multifput "order #{order_number} color #{@settings['fletch_paint']}", "buy"
		else
			order_number = find_order_num(item)
			multifput "order #{order_number}", "buy"
		end
		
		#wait up to three seconds to see if purchase was succesful
		endtime = Time.now + 3
		loop {
			if checkright.nil?
				sleep 1
			elsif Time.now > endtime
				echo "For some reason buying an item failed"
				exit
			elsif checkright
				echo "got item"
				break
			end
		}
		stow_check = dothistimeout "put my #{checkright} in my #{@settings['fletch_sack']}", @settings['timeout_duration'].to_i, /won't fit|You put a/
		if stow_check =~ /won't fit/
			echo "fletchsack full, stopping"
			exit
		elsif stow_check.nil?
			echo "stowcheck failed, stopping"
			exit
		end
		
	}
	@spent_silver += (5000 - checksilver)
	
	start_script "go2",['bank']
	wait_while {running?("go2")}
	fput "unhide" if hidden? or invisible?
	fput "depo all"
	if invis and Spell[916].affordable?
		fput "incant 916"
	end
	start_script "go2",[start_room]
	wait_while {running?("go2")}
	return @spent_silver
end

def mf_buyIfOut()
	fletch_sack_contents = get_container_contents(@settings['fletch_sack'])
	@needed_items = check_needed_items(fletch_sack_contents)
	if !@needed_items.empty?
		if !@settings['fletch_enable_buying']
			echo "Run out of #{@needed_items[0]} and the script is not set to buy more, ';fletching setup' to change this."
			exit
		end
		respond ""
		@needed_items.each{|item|
			respond "Out of #{item}"
		}
		respond "Off to buy"
		respond ""
		sleep 1
		@spent_silver += buy_items()
		needed_items = Array.new
	end
end

def failed(msg)
	echo msg
	exit
end

def getItem(item)
	waitrt?
	check = dothistimeout "get #{item}", @settings['timeout_duration'].to_i, /You remove|You reach for|get what?/
	if check =~ /get what?/
		echo "Could not get your axe to cut the shafts"
		return false;
	elsif check.nil?
		failed("Could not get your #{item}")
	else
		return true;
	end 
end

def stowItem(item, container)
	fput "put my #{item} in my #{container}"
	endtime = Time.now + 6
	loop{
		if checkright.nil?
			break
		elsif Time.now > endtime
			failed("Stowing item failed");
		else
			sleep 0.5
		end
	}
end

def stowleft()
	return if checkleft.nil?
	fput "put left in my #{@settings['fletch_sack']}"
	again = false
	endtime = Time.now + 6
	loop{
		if checkleft.nil?
			break
		elsif Time.now > endtime -3 and !again
			again = true
			fput "put left in my #{@settings['fletch_sack']}"
		elsif Time.now > endtime
			"Stowing item failed"
		else
			sleep 0.1
		end
	}
end

def bundle()
	#gameobj does not get full descriptions so have to go about it ma self
	
	quiver_contents_string = nil
	quiver_contents = proc{|server_string|
		if server_string =~ /^\AIn the <a exist="\d+" noun="\w+">\D+<\/a> you see a/		
			quiver_contents_string = server_string
			nil
		else			
			server_string
		end
	}
	DownstreamHook.add('fletch_check_quiver', quiver_contents)	
	
	fput "look in my #{@settings['fletch_quiver']}"
	
	endtime = Time.now + 3
	loop {
		if quiver_contents_string != nil
			DownstreamHook.remove('fletch_check_quiver')
			break
		elsif Time.now > endtime
			echo "failed to get the contents of #{@settings['fletch_quiver']}"
			DownstreamHook.remove('fletch_check_quiver')
			exit
		else
			sleep 0.1
		end
	}
		
	#if quiver_contents_string =~ /^\AIn the <a exist="(\d+)" noun="(\w+)">(?:\D+)<\/a>(?:\D+)</
	if quiver_contents_string =~ /^\AIn the <a exist="(\d+)" noun="(\w+)">(?:\D+)<\/a> you see an? (.*)./	
		quiver_contents = $3.to_s.gsub( /["]/ , '\'' )
		quiver_contents = quiver_contents.scan(/<a exist='\d+' noun='\w+'>(?:\D+)<\/a>/)		
	else
		echo "contents malformed"
	end
	contents = Hash.new
	quiver_contents.each{|item|
		#if item =~ /(.+)<a exist='(\d+)' noun='([\w\-]+)'>([\w\s\-']+)<\/a>([\s\w'\-]+)?/
		if item =~ /<a exist='(\d+)' noun='(\w+)'>(\D+)<\/a>/			
			item_id = $1
			item_noun = $2
			item_full_name = $3.strip;
#			item_full_name = item_full_name.strip + "#{$1.strip}"
#			item_full_name = item_full_name.strip + " #{$4.strip} "
#			item_full_name = item_full_name.strip + " #{$5.strip}"
#			item_full_name.strip!
		end
		contents[item_id] = item_full_name
	}
	#finds the description of each different type of arrow
	arrow_types = Array.new
	contents.each_pair{|id,name|
		if name =~ /arrow$/ and !arrow_types.include? name
			arrow_types << name
		end
	}
	arrow_types.each{|desc|
		contents.each_pair{|id,name|
			if desc =~ /#{name}/
				if checkright.nil? 
					fput "get ##{id} from my #{@settings['fletch_quiver']}"
					endtime = Time.now + 6
					wait_until{!checkright.nil? || Time.now > endtime}
				else
					fput "get ##{id} from my #{@settings['fletch_quiver']}"
				end
				if !checkleft.nil? and !checkright.nil?
					check = dothistimeout "bundle", @settings['timeout_duration'].to_i, /You bundle your arrows together.|You add a .+ arrow to your bundle.|You may not combine more than 100 shafts./
					if check.nil?
						echo "bundling failed for some reason, stopping"
						exit
					elsif check =~ /You may not combine more than 100 shafts./
						fput "put right in my #{@settings['fletch_quiver']}"
					end
					endtime = Time.now + 6
					wait_until{checkleft.nil? || Time.now > endtime}
				end
			end
		}
		fput "put right in my #{@settings['fletch_quiver']}"
	}
	#now arrows are bundled see about condensing the bundles down
	bundle_ids = Array.new
	quiver_contents = get_container_contents(@settings['fletch_quiver'])
	quiver_contents.each{|item|
		if item.name =~ /bundle of arrows/
			bundle_ids << item.id
		end
	}
	
	bundle_amount = Array.new
	bundle_desc = Array.new
	bundle_check = proc{|server_string|
	#
	#Individual projectiles from this bundle will have a long of "a wooden arrow"
	#
		if server_string.nil?
			#nil
		elsif server_string =~ /You carefully count the <a exist="\d+" noun="\w+">\w+<\/a> and find (\d+) in the bundle, each one being .+, with a strength of \d+ and a durability of \d+./
			bundle_amount << $1
			nil
		elsif server_string =~ /Individual projectiles from this bundle will have a long of "([\w\s]+)"/
			bundle_desc << $1
			nil
		elsif server_string =~ /Each individual projectile will be "[\w\s]+"./
			nil
		elsif server_string =~ /<prompt time="\d+">&gt;<\/prompt>/
			nil
		else
			if server_string.length > 2
				server_string
			else
				nil
			end
		end
	}
	DownstreamHook.add('fletch_budle_check', bundle_check)
	silence_me
	bundle_ids.each{|id|
		fput "look ##{id}"
	}
	silence_me
	endtime = Time.now + 6
	wait_until{bundle_ids.length == bundle_desc.length || Time.now > endtime}
	DownstreamHook.remove('fletch_budle_check')
	if bundle_ids.length != bundle_desc.length
		echo "failed to get bundles info, stopping"
		exit
	end
	x = 0
	bundles = Array.new
	until x == bundle_ids.length
		bundles << bundle = {
			"id" => bundle_ids[x],
			"count" => bundle_amount[x],
			"desc" => bundle_desc[x]
		}
		x +=1
	end
	uniq_bundle_desc = bundle_desc & bundle_desc
	last_bundle = ""
	uniq_bundle_desc.each{|desc|
		total = 0
		bundles.each{|bundle|
			if bundle['desc'] == desc and total == 0 and bundle['count'].to_i!=100
				#there is a match but if there might only be one of that bundle so take note but do nothing
				total += bundle['count'].to_i
				last_bundle = bundle['id'].dup
			elsif bundle['desc'] == desc and total > 0 and bundle['count'].to_i!=100
				#match and the total is already above 0, must of already found a bundle of the same arrows
				total += bundle['count'].to_i
				if total < 100
					fput "get ##{bundle['id']}"
					matchtimeout 1, "You remove"
					fput "get ##{last_bundle}" if checkleft.nil?
					fput "bundle"
					last_bundle = bundle['id']
				else
				
					if total == 100
						fput "get ##{bundle['id']}"
						matchtimeout 1, "You remove"
						fput "get ##{last_bundle}" if checkleft.nil?
						fput "bundle"
						fput "stow r"
						total = 0
					else
						amount_over = total - 100
						amount_to_get = bundle['count'].to_i - amount_over
						fput "get #{amount_to_get} ##{bundle['id']}"
						matchtimeout 1, "You remove"
						fput "get ##{last_bundle}" if checkleft.nil?
						fput "bundle"
						fput "stow r"
						bundle['amount'] = bundle['amount'].to_i - amount_to_get	#resize the bundle
						bundles << bundle											#and add back on the end
						total = 0
					end					
				end
			end
		}		
		fput "put right in my #{@settings['fletch_quiver']}" if !checkright.nil?
	}
end

def getBow()
	check = dothistimeout "remove my #{@settings['fletch_bow']}", @settings['timeout_duration'].to_i, /You sling|remove what?/
	if check =~ /remove what?/
		echo "Failed to get your bow."
		exit
	elsif check.nil?
		endtime = Time.now + 5
		loop {
			if checkleft =~ /bow/
				break
			elsif Time.now > endtime
				echo "Failed to get your bow."
				exit
			else
				sleep 1
			end
			}
	end

end

def mf_make_shafts()
 waitrt?
 check = getItem("my wood in my #{@settings['fletch_sack']}")
 check = getItem(@settings['fletch_axe']);
 if @check 
 	failed("Could not get your axe to cut the shafts");
 end 
 fput "cut arrow shaft my wood";
 waitrt?
 if checkright =~ /shaft/
	stowleft();
	fput "put right in my #{@settings['fletch_sack']}";
 else 
	failed("Failed to cut shafts.");
 end
end

def mf_par_shaft()
 waitrt?
 check = getItem("1 my shaft");
 if !check
	failed("Ran out of shafts some how");
 end
 check = getItem("my #{@settings['fletch_knife']}");
 if !check
	failed("Unable to find your #{@settings['fletch_knife']}");
 end
 fput "CUT MY SHAFT WITH MY #{@settings['fletch_knife']}";
 waitrt?
end

def mf_paint_shaft()
 waitrt?
 if @settings['fletch_paint'] != 0
		stowleft(settings)
		paint = @paints[settings['fletch_paint']].split(" ")
		fput "get my #{paint[0]} paint"
		endtime = Time.now + 6
		loop{
			if checkleft =~ /paint/
				break
			elsif Time.now > (endtime - 3)
				fput "get my #{paint[0]} paint"
			elsif Time.now > endtime
				echo "Run out of paint, probably means you have another colour paint on you messing with my check. Get it out your fletchsack"
				exit
			else
				sleep 0.5
			end
		}
		haste!
		check = dothistimeout "paint my shaft", @settings['timeout_duration'].to_i, /You carefully smear a bit of paint/
		if check.nil?
			#if the first check failed for some reason double check by looking at the arrow
			check = dothistimeout "look my shaft", @settings['timeout_duration'].to_i, /The arrow shaft has been pared down and smoothed.$|The arrow shaft has been pared down and smoothed.  A coat of .+ paint covers the shaft./
			if check !~ /The arrow shaft has been pared down and smoothed.  A coat of .+ paint covers the shaft./
				echo "Could not determine if painting was succesful, stopping"
				exit
			end
		end
		check = matchtimeout 40, "The paint on your arrow shaft has dried." 
		if !check
			echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
		end
		stowleft(settings)
		
	end
	#paintstick1
	if settings['fletch_paintstick1'].length > 0
		stowleft(settings)
		fput "get my #{settings['fletch_paintstick1']}"
		endtime = Time.now + 6
		loop{
			if checkleft =~ /paintstick/
				break
			elsif Time.now > (endtime - 3)
				fput "get my #{settings['fletch_paintstick1']}"
			elsif Time.now > endtime
				echo "Could not get your paintstick"
				exit
			else
				sleep 0.5
			end
		}
		haste!
		check = dothistimeout "paint my shaft", @settings['timeout_duration'].to_i, /You carefully apply a band of/
		if check.nil?
			#if the first check failed for some reason double check by looking at the arrow
			check = dothistimeout "look my shaft", @settings['timeout_duration'].to_i, /It looks like someone has painted a single .+ band on the end/
			if check !~ /It looks like someone has painted a single .+ band on the end/
				echo "Could not determine if painting was succesful, stopping"
				exit
			end
		end
		check = matchtimeout 40, "The paint on your arrow shaft has dried." 
		if !check
			echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
		end
		waitrt?
		stowleft(settings)
	end
	
	#paintstick2
	if settings['fletch_paintstick2'].length > 0
		stowleft(settings)
		fput "get my #{settings['fletch_paintstick2']}"
		endtime = Time.now + 6
		loop{
			if checkleft =~ /paintstick/
				break
			elsif Time.now > (endtime - 3)
				fput "get my #{settings['fletch_paintstick2']}"
			elsif Time.now > endtime
				echo "Could not get your paintstick"
				exit
			else
				sleep 0.5
			end
		}
		haste!
		check = dothistimeout "paint my shaft", @settings['timeout_duration'].to_i, /You carefully apply a band of/
		if check.nil?
			#if the first check failed for some reason double check by looking at the arrow
			check = dothistimeout "look my shaft", @settings['timeout_duration'].to_i, /It looks like someone has painted a pair of .+ and .+ bands on the end.|It looks like someone has painted a single .+ band on the end/
			if check !~ /It looks like someone has painted a pair of .+ and .+ bands on the end.|It looks like someone has painted a single .+ band on the end/
				echo "Could not determine if painting was succesful, stopping"
				exit
			end
		end
		check = matchtimeout 40, "The paint on your arrow shaft has dried." 
		if !check
			echo "Did not see paint dry for some reason, carrying on in case it did but might cause problems if it didn't"
		end
		waitrt?
		stowleft(settings)
	end
end

def mf_nock_shaft()
 waitrt?
 getItem(@settings['fletch_knife']) if @settings['fletch_paint'] != 0 
 fput "CUT NOCKS IN MY SHAFT WITH MY #{@settings['fletch_knife']}";
 fput "CUT NOCKS IN MY SHAFT WITH MY #{@settings['fletch_knife']}" if @settings['fletch_paint'] == 0;
 waitrt?
 stowleft();
end

def mf_measure_shaft()
	waitrt?
	getBow();
	check = dothistimeout "measure my shaft with my #{@settings['fletch_bow']}", @settings['timeout_duration'].to_i, /When the bow string reaches optimal tension, you carefully un-nock the shaft and ease the string forward while grasping the shaft with your left hand to mark the length until you can make a tiny cut on the shaft./
	if check.nil?
		failed("failed to measure, do something about this later");
	end
	waitrt?
	check = dothistimeout "wear my #{@settings['fletch_bow']}", @settings['timeout_duration'].to_i, /You sling .+ over your shoulder./
	if check.nil?
		echo "failed to wear bow, do something about this later"
		exit
	end	
end

def mf_cut_shaft()
	waitrt?
	getItem(@settings['fletch_knife']);
	check = dothistimeout "cut my shaft with my  #{@settings['fletch_knife']}", @settings['timeout_duration'].to_i, /Using your previous mark as a guide, you cleanly slice the end off the arrow shaft.|You might want to think about attaching fletchings first./
	if check.nil?
		failed("failed to cut shaft, do something about this later");
	end
	waitrt?
	stowleft();
end

def mf_glue_shaft()
	waitrt?
	check = dothistimeout "get my glue", @settings['timeout_duration'].to_i, /You remove|Get what?/
	if check =~ /Get what?/
		mf_buyIfOut();
		getItem("shaft");
		mf_glue_shaft();
		return;
	elsif check.nil?
		failed("Could not get your glue.")
	end 
	check = dothistimeout "put my glue on my shaft", @settings['timeout_duration'].to_i, /You carefully smear a bit of glue/
	if check.nil?
		failed("failed, do something about this later");
	end
	waitrt?
	stowleft();
end

def mf_add_fletching()
	mf_glue_shaft();
	waitrt?
    check = dothistimeout "get 3 my fletching", @settings['timeout_duration'].to_i, /You remove|You reach for|Get what?/
	if check =~ /Get what?/
		mf_buyIfOut();
		mf_add_fletching();
	elsif check.nil?
		failed("Could not get your fletchings.")
	end 

	check = dothistimeout "put my fletching on my shaft", @settings['timeout_duration'].to_i, /You attach your|Unfortunately, the glue is now too dry to remove them and try again, so you discard|Luckily, you are able to salvage the shaft./
	if check =~/Unfortunately, the glue is now too dry to remove them and try again, so you discard /
		waitrt?
		return
	elsif check =~/Luckily, you are able to salvage the shaft./
		waitrt?
		mf_add_fletching();	
	else
		check = matchtimeout 60, "The glue on your arrow shaft has dried."
		if check == false
			failed("Didn't see glue dry for some reason, stopping");
		end
	end
	
	#if !(checkright =~ /shaft/ and checkleft.nil?)
	#	failed("failed, do something about this later");
	#end
end

def mf_whittle_tip()
	waitrt?
	getItem(@settings['fletch_knife']);
 	put "cut my shaft with my  #{@settings['fletch_knife']}"
	put "cut my shaft with my  #{@settings['fletch_knife']}"
	check = matchtimeout 6, "With a few quick cuts,", "Working a bit too hastily, you slice the end right off!"
	if check == false
		failed("didnt see you cut the shaft for some reason, stopping")
	end
	waitrt?
	stowleft()

end

def mf_drill_shaft()
 waitrt?
 getItem("drill"); 
 fput "turn my drill"
 waitrt?
 stowleft();
end

def mf_add_tip()
	waitrt?
	mf_drill_shaft();
	waitrt?
	getItem(@settings['fletch_tip']);
	fput "turn my #{@settings['fletch_tip']}"
	waitrt?
end

def mf_make_tip()
	if(@settings['fletch_tip'].nil? or @settings['fletch_tip'] == "")
		mf_whittle_tip();
	else
		mf_add_tip();
	end
end

def mf_make_arrow()
	fletch_sack_contents = get_container_contents(@settings['fletch_sack'])
	if fletch_sack_contents.to_s.include? 'wood'
		mf_make_shafts()
	end
	
	#Par Shafts
	mf_par_shaft();
	if checkright !~ /shaft/
		stowleft();
		return;
	end
	
	#Paint Shafts if selected
	#mf_paint_shaft();
	
	#Cut nocks in shaft
	mf_nock_shaft();
	if checkright !~ /shaft/
		return
	end
	
	#Measure Shaft
	mf_measure_shaft();
	
	#Cut Shafts
	mf_cut_shaft();
	if checkright !~ /shaft/
		stowleft();
		return;
	end
	
	#Add Fletchings
	mf_add_fletching();
	
	if checkright !~ /shaft/
		stowleft()
		return
	end
	
	mf_make_tip();
end

def startup()
	silence_me
	if variable[0] =~ /setup|config|configure/i
		@setup.call
		exit
	elsif variable[0] =~ /bundle/i
		bundle()
		exit
	elsif !variable[0].nil?
		message = ""
		message += "This script needs a map room if you want it to buy items for you. If this is the case when ever you run out of an item the script will run and buy more\r\n"
		message += "Run ;fletching setup at any times to change you settings\r\n"
		message += "Anytime the script is running ;fletching will give you a progress report. ;fletching stop will tell the script to end after finishing the arrow it is curently on. This is the prefered method of stopping, partially cut shafts left in a container migt cause the script to fail\r\n"
		
		if !$fake_stormfront
			puts "<output class=\"mono\"/>#{monsterbold_start}#{message}#{monsterbold_end}\r\n<output class=\"\"/>"
		else
			puts "#{monsterbold_start}#{message}#{monsterbold_end}"
		end
		exit
	end
	warning = "";
	if @settings['fletch_sack'] == "" or @settings['fletch_sack'].nil?
		warning += "The container for you supplies has not yet been set, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_quiver'] == "" or @settings['fletch_quiver'].nil?
		warning += "The container for you finished arrows has not yet been set, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_knife'] == ""
		warning += "Have not set a knife/dagger to cut the shafts with, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_bow'] == ""
		warning += "Have not set a bow to measure the shafts with, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_axe'] == ""
		warning += "Have not set an axe to make shafts with, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_wood'] == ""
		warning += "Have not set a what wood you want to use, the script will not run untill this is added.\r\n"
	end
	if @settings['fletch_wood'] != "" and @settings['fletch_wood'] !~ /wood/
		warning += "You have set what wood you want to use but appears you may have done so incorectly. It should read along the lines of 'limb of wood' or 'branch of faewood' for example. Leave off any a/an/some from the start\r\n"
	end
	if @settings['fletch_fletchings'] != "" and @settings['fletch_fletchings'] !~ /fletching/
		warning += "You have set what fletchings you want to use but appears you may have done so incorectly. It should read along the lines of 'bundle of fletchings' for example. Leave off any a/an/some from the start.\r\n"
	end
	if warning.length > 0
		if !$fake_stormfront
			puts "<output class=\"mono\"/>#{monsterbold_start}#{warning}#{monsterbold_end}\r\n<output class=\"\"/>"
		else
			puts "#{monsterbold_start}#{warning}#{monsterbold_end}"
		end
		@setup.call
		exit
	end
	monitor_interaction()
	empty_left_hand
	empty_right_hand
	loop{
		if @settings['waggle']
			start_script "waggle"
			wait_while {running?("waggle")}
		end

		mf_buyIfOut();
		
		mf_make_arrow();
	
		if checkright =~ /arrow/
			if @settings['fletch_drop']
				fput "drop right";
			else
				fput "put right in my #{@settings['fletch_quiver']}";
			end
			@arrows_made += 1
		else
			@arrows_failed += 1
		end
		
		respond ""
		respond "Script has been running for #{Time.at(Time.now - @start_time).utc.strftime("%H hours, %M minutes %S seconds")}, made #{@arrows_made} arrows, ruined #{@arrows_failed} arrows and spent #{@spent_silver} silver"
		respond ""
		exit if @finished
		exit if @settings['fletch_limit'].to_i > 0 and @arrows_made == @settings['fletch_limit'].to_i
	}
	silence_me
end
startup();